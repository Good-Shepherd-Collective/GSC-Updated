---
import BaseLayout from "@/layouts/BaseLayout.astro";

import fetch from '@11ty/eleventy-fetch';

console.log("Script start NAD again");


async function fetchDailyReports() {
  try {
    const response = await fetch(
      "https://us-east-1.aws.data.mongodb-api.com/app/daily_reports-qqsah/endpoint/daily_report",
      {
        duration: '1d', // Cache the data for 1 day
        type: 'json'    // Specify that we expect JSON data
      }
    );



    const parsedData = JSON.parse(response.body);

    console.log("NAD data:", parsedData);

    parsedData.forEach(report => {
      report.data.forEach(item => {
        if (item.Value === null) {
          item.Value = 0;
        }
      });
    });
    return parsedData;
  } catch (error) {
    console.error("Fetch error:", error);
    return [];
  }
}


function formatDate(timestamp) {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${month}.${day}.${year}`;
}

function formatTimestamp(timestamp) {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${month}.${day}.${year} ${hours}:${minutes}`;
}

// Fetch and process data server-side
const reports = await fetchDailyReports();
const serializedReports = JSON.stringify(reports);

// Prepare data for each category
const categories = ["Deaths", "Military checkpoints", "Settler attacks", "Road closures", "Confiscation of property", "Injuries", "Temporary checkpoints"];
const categoryData = categories.map(category => {
  const mostRecentReport = reports.reduce((latest, report) => {
    
    const latestDate = new Date(latest.metadata.Date);
    const currentDate = new Date(report.metadata.Date);

    // console.log("Comparing dates:", latestDate, "and", currentDate)
    return currentDate > latestDate ? report : latest;
  }, reports[0]);

  let categoryItem = mostRecentReport.data.find(item => item["Description English"] === category);
  if (!categoryItem) {
    categoryItem = { "Description English": category, "Value": "0" };
  }

  return {
    category,
    value: categoryItem["Value"],
    date: mostRecentReport.metadata.Date // Use the 'Date' directly from the metadata
  };
});

console.log("Category NAD Data:", categoryData);
// Find the most recent report
const mostRecentReport = reports.reduce((latest, report) => {
  const latestDate = new Date(latest.metadata.Date);
  const currentDate = new Date(report.metadata.Date);
  return currentDate > latestDate ? report : latest;
}, reports[0]);

// Format the date for display
const mostRecentDate = mostRecentReport.metadata.Date;
const formattedMostRecentDate = formatDate(mostRecentDate);
console.log("Most Recent Date:", mostRecentDate);
const formattedMostRecentTimestamp = formatTimestamp(mostRecentReport.metadata["Timestamp"]);
---
<BaseLayout title="Daily Report" description="Daily report of settler-colonial violence in the West Bank and East Jerusalem.">
  <section class="md:px-12 sm:px-8">
    <div class="border-x border-zinc-800 p-8">
      <div style="max-width: 55rem; margin: 0 auto;">
<h2 class="text-4xl md:text-6xl xl:text-7xl text-white" style="margin-bottom: 2.5rem;">Daily Report</h2>
<p>This data set represents a small subsection of Israeli settler-colonial violence. These figures represent reporting from the West Bank and East Jerusalem and does not account for the colonial violence enacted upon Palestinians residing in the lands of occupied Palestine in 1948. However, the <code>Deaths</code> total includes the Palestinians Israel has killed in Gaza. The datum here is translated and compiled from Palestinian institutions. This particular data set is based on Palestinian Negotiations Affairs Department information. The <code>Total</code> amount reflects the aggregate of a single day on the date of {formattedMostRecentDate}.</p>

{
  reports.length > 0 ? (
    <table class="nad">
      <thead>
        <tr class="header">
          <th>Category</th>
          <th>Total</th>
          <th>5 day avg</th>
          <th>10 day avg</th>
          <th style="width: 300px;">Trend</th>
        </tr>
      </thead>
      <tbody>
        {categoryData.map(({ category, value, date }) => (
          <tr key={`report-category-${category}`}>
            <td data-cell="Category">{category}</td>
            <td data-cell="Total"  class="value">{value}</td>
            <td data-cell="5 day avg" class="average" id={`five-day-average-${category}`}></td>
            <td data-cell="10 day avg" class="average" id={`ten-day-average-${category}`}></td>
            <td class="trend">
              <div class="trend-title"></div>
              <canvas class="border-x border-zinc-800" data-cell="Trend" id={`chart-latest-${category}`} height="60 !important" />
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  ) : (
    <p>No reports available.</p>
  )
}
<p class="time__stamp">Data updated: {formattedMostRecentTimestamp}&nbsp;|&nbsp;<a href="/data/daily_report.csv" download="daily_report.csv">Download as CSV</a>&nbsp;|&nbsp;
  <a href="/data/daily_report.xlsx" download="daily_report.xlsx">Download as Excel</a> </p>
<div id="chartData" data-reports={serializedReports} style="display:none;"></div>
</div>
</div>
</section>
</BaseLayout>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", () => {
  // Function to dynamically load Chart.js and initialize charts
  async function loadChartJsAndInitializeCharts() {
    console.log("Loading Chart.js dynamically...");

    const chartJsScript = document.createElement('script');
    chartJsScript.src = 'https://cdn.jsdelivr.net/npm/chart.js';
    document.body.appendChild(chartJsScript);

    await new Promise((resolve, reject) => {
      chartJsScript.onload = resolve;
      chartJsScript.onerror = reject;
    });

    console.log("Chart.js loaded. Initializing charts...");
    initializeCharts();
  }

  // Function to calculate average
  function calculateAverage(values) {
    const sum = values.reduce((a, b) => a + b, 0);
    return (sum / values.length).toFixed(2);
  }

  // Function to calculate percentage increase
  function calculatePercentageIncrease(fiveDayAvg, tenDayAvg) {
    if (tenDayAvg === 0) {
      return 0;
    }
    return ((fiveDayAvg - tenDayAvg) / tenDayAvg * 100).toFixed(2);
  }

  // Function to prepare chart data for a category
  function prepareChartDataForCategory(reports, description) {
    const chartData = [];
    const averages = { fiveDay: [], tenDay: [] };

    reports.forEach((report, index) => {
      const dataItem = report.data.find(item => item["Description English"] === description);
      const value = dataItem ? parseInt(dataItem.Value, 10) : 0;
      chartData.push(value);

      if (index >= 4) {
        averages.fiveDay.push(calculateAverage(chartData.slice(-5)));
      }
      if (index >= 9) {
        averages.tenDay.push(calculateAverage(chartData.slice(-10)));
      }
    });

    return { chartData, averages };
  }

  // Function to apply conditional formatting
  function applyConditionalFormatting(element, percentageIncrease) {
    const transparency = Math.min(1, Math.abs(percentageIncrease) / 100);
    if (percentageIncrease > 0) {
      element.style.backgroundColor = `rgba(127, 13, 1, ${transparency})`;
      element.setAttribute('data-after', '↑');
    } else if (percentageIncrease < 0) {
      element.style.backgroundColor = `rgba(40, 169, 224, ${transparency})`;
      element.setAttribute('data-after', '↓');
    } else {
      element.style.backgroundColor = '';
      element.removeAttribute('data-after');
    }
    element.style.fontWeight = transparency >= 0.6 ? '600' : 'normal';
    element.style.color = transparency >= 0.6 ? 'white' : '';
  }

  // Function to initialize charts
  function initializeCharts() {
    const chartDataDiv = document.getElementById("chartData");
    let reports = JSON.parse(chartDataDiv.getAttribute("data-reports"));

    // Sort reports by the Date within the metadata before generating the chart
    reports.sort((a, b) => new Date(a.metadata.Date) - new Date(b.metadata.Date));

    const categories = ["Deaths", "Military checkpoints", "Settler attacks", "Road closures", "Building the separation wall", "Confiscation of property", "Injuries", "Temporary checkpoints"];
    categories.forEach(selectedCategory => {
      const { chartData, averages } = prepareChartDataForCategory(reports, selectedCategory);
      const labels = reports.map(report => report.metadata.Date); // Now sorted chronologically

      const canvasId = `chart-latest-${selectedCategory}`;
      const canvasElement = document.getElementById(canvasId);
      if (!canvasElement) {
        console.error(`Canvas element not found for ID: ${canvasId}`);
        return;
      }
      const ctx = canvasElement.getContext("2d");

      const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);

// Adjust the second stop (0.2 in this example) to control the start of the fade
// Adjust the third stop (0.5 in this example) to control where it becomes fully transparent
gradient.addColorStop(0, '#7f0d15'); // Solid color at the top
gradient.addColorStop(0.05, 'rgba(127, 13, 21, 0.5)'); // Start fading
gradient.addColorStop(0.45, 'rgba(127, 13, 21, 0)'); // Fully transparent before the bottom

new Chart(ctx, {
  type: "line",
  data: {
    labels: labels,
    datasets: [{
      label: selectedCategory,
      data: chartData,
      borderColor: "#7f0d15",
      tension: 0.1,
      borderJoinStyle: 'round',
      borderWidth: 1,
      pointRadius: .5,
      backgroundColor: gradient, // Apply the updated gradient here
      fill: true, // Ensure the area under the line is filled
    }]
  },
  options: {
    plugins: {
      legend: {
        display: false
      }
    },
    scales: {
      x: {
        ticks: {
          display: false
        },
        grid: {
          display: false,
        }
      },
      y: {
        ticks: {
          display: false
        },
        grid: {
          display: false,
        }
      }
    }
  }
});

      const fiveDayAvgElement = document.getElementById(`five-day-average-${selectedCategory}`);
      const tenDayAvgElement = document.getElementById(`ten-day-average-${selectedCategory}`);
      if (fiveDayAvgElement && tenDayAvgElement) {
        const fiveDayAvg = averages.fiveDay[averages.fiveDay.length - 1];
        const tenDayAvg = averages.tenDay[averages.tenDay.length - 1];

        fiveDayAvgElement.textContent = fiveDayAvg;
        tenDayAvgElement.textContent = tenDayAvg;

        const percentageIncrease = calculatePercentageIncrease(parseFloat(fiveDayAvg), parseFloat(tenDayAvg));
        applyConditionalFormatting(fiveDayAvgElement, percentageIncrease);
      }
    });
  }

  // Intersection Observer callback
  function handleIntersection(entries, observer) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        console.log("Chart container is in view. Loading Chart.js...");
        loadChartJsAndInitializeCharts();
        observer.unobserve(entry.target);
      }
    });
  }

  // Set up the Intersection Observer
  const observer = new IntersectionObserver(handleIntersection, {
    root: null,
    threshold: 0.1
  });

  const chartContainers = document.querySelectorAll('.nad');
  chartContainers.forEach(container => observer.observe(container));
});
</script>



<style>
  .nad {
    width: 100%;
    border-collapse: collapse;
    margin-top: 2rem;
  }

  .average[data-after]::after {
    content: attr(data-after);
    margin-left: 10px; /* Adjust as needed */
}

.canvas{
  height: 60px !important;
}

.percentage{
    font-weight: 600;
  }

  .value{
    width: 80px;
  }

  th{
    text-align: left;
  }

td{
  border-bottom: 1px solid #222;
}
  
    

  @media screen and (max-width: 768px) {
   
    .data__table {
      margin-top: 1rem;
    }
    th {
      display: none !important;
    }

    td {
      display: grid !important;
      grid-template-columns: 13ch auto;
    }

    td:first-child {
      padding-top: 1rem;
    }

    td:last-child {
      padding-bottom: 1rem;
    }

    td::before {
      content: attr(data-cell) ": ";
      font-weight: 700;
    }

    .trend::before{
      content: "Trend";
    }

    .aggregate td {
      font-weight: 700;
      border-bottom: none;
    }

    .aggregate td:last-child {
      border-bottom: #222 solid 2px;
    }
    .aggregate td:first-child {
      display: none !important;
    }

    .aggregate td:nth-child(2) {
      padding-top: 1rem;
      border-top: #222 solid 2px;
    }

    .average[data-after]::after {
    content: "";
    margin-left: 10px; /* Adjust as needed */
}
  }
</style>